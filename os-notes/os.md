<h1 align="center">操作系统复习小结</h1>

##第一章: 操作系统引论

###操作系统的目标和作用和发展动力

####目标:
  1. 有效性  
  2. 方便性
  3. 可扩充性
  4. 开放性

####作用: 
  1. OS作为用户与计算机硬件资源之间的接口
  2. OS作为计算机系统资源的管理者
  3. OS实现了对计算机资源的抽象

####动力
  1. 不断提高计算机资源的利用率
  2. 方便用户
  3. 器件的不断更新换代
  4. 计算机体系结构的不断发展

###操作系统发展过程

1. 无操作系统的计算机系统
2. 单道批处理系统(自动性，顺序性，单道性)
3. 多道批处理系统(资源利用率高，系统吞吐量大，平均周转时间长，无交互能力)
4. 分时系统(多路性，独立性，及时性，交互性)
5. 实时系统(多路性，独立性，及时性，交互性,可靠性!)

###操作系统的基本特性
1. 并发性(并行:同时进行，并发：一段时间内间隔发生，引入进程、线程，一个进程包含多个线程)
2. 共享性(系统中的资源可供内存中的多个并发执行的进程或线程共同使用，存在互斥共享和同时访问)
3. 虚拟技术(时分复用技术，空分复用技术)
4. 异步性

###操作系统的主要功能
1. 处理机管理功能(进程控制，进程同步，进程通信，调度)
2. 存储器管理功能(内存分配，内存保护，地址映射，内存扩充)
3. 设备管理功能(缓冲管理，设备分配，设备处理)
4. 文件管理功能(文件存储空间管理，目录管理，文件的读、写管理和保护)
5. 操作系统与用户之间的接口(用户接口，程序接口)

###OS结构设计
1. 传统的操作系统
2. 客户/服务器模式
3. 面向对象的程序设计
4. 微内核OS结构



##第二章: 进程管理

###进程的基本概念

####程序的顺序执行及其特征
1. 顺序性
2. 封闭性
3. 可再现性 因为是顺序执行的，所以再次执行一定会有相同的结果


####程序的并发执行及其特征  
1. 间断性
2. 失去封闭性
3. 不可再现性

####程序控制块
  为了描述和控制进程的运行，系统为每一个进程定义了一个数据结构---进程控制块，它是进程实体的一部分  
  是操作系统中最重要的记录型数据结构。PCB记录了操作系统所需的、用于描述进程当前情况以及控制进程运行  
  的全部信息。进程控制块的作用是使一个在多道程序环境下不能独立运行的程序（含数据），成为一个能独立运行  
  的基本单位，一个能与其他进程并发执行的进程。创建进程时建立PCB,进程结束时回收其PCB。

  PCB
    1. 进程标识符
    2. 处理机状态
    3. 进程调度信息
    4. 进程控制信息


###进程控制


###进程同步
  在OS中引入进程后，虽然提高了资源的利用率和系统的吞吐量，但由于进程的异步性，也会给系统造成混乱，尤其  
  是它们在争夺临界资源时，例如当多个进程取争用一台打印机时，有可能使用多个进程的输出结果交织在一起，难于  
  区分，而当多个进程去争用共享变量、表格、链表时，有可能致使数据处理出错。进程同步的主要任务就是对多个进程  
  在执行次序上进行协调，以使并发执行的诸进程之间能有有效地共享资源和相互合作，从而使程序的执行具有可再现性。

  信号量：！！！！！！  
  互斥信号量！！！  

  生产者消费者模式 - 利用管程解决
  输入时，输入进程是生产者，计算进程是消费者，而在输出时，计算进程是生产者，而打印进程是消费者。因此，该问题  
  的代表性以及实用价值很大。

  哲学家进餐问题 - 利用记录型信号量解决哲学家进餐问题
  五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在圆桌上有五个碗和五只筷子，它们的生活方式就是交替的进行  
  思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右手最靠近他的筷子，只有在他拿到两只筷子时才能进餐，  
  进餐完毕，放下筷子思考。

  读者-写者问题 - 利用记录型信号量解决
  允许多个进程同时读一个共享对象，因为读操作不会使数据文件混乱，但是不允许一个writer进程和其他reader进程或writer  
  进程同时访问共享对象，因为这种访问会引起混乱。所谓“读者-写者”问题是指保证一个writer进程必须与其他进程互斥地访问  
  共享对象的同步问题，读者-写者问题常备用来测试新同步原语。


####进程同步的基本概念
####信号量机制
####信号量的应用

###经典进程的同步问题

####生产者-消费者问题
####哲学家进餐问题
####读者-写者问题

###进程通信
  进程通信，是指进程之间的信息交换，其所交换的信息量少则是一个状态或数值，多者则是成千上万个字节，进程  
  通信之间的互斥和同步，由于其所交换的信息量少而被归结为低级通信。在进程互斥中，进程通过只修改信号量  
  来向其他进程表明临界资源是否可用，在生产者-消费者的问题中，生产者通过缓冲池将所产生的产品传送给消费者。


###线程
  线程是一种比进程更小的能独立运行的基本单位，试图用它来提高系统内程序的并发执行程度，从而进一步提高系统的吞吐量  
  特别是多处理机系统的迅速发展，线程比进程更好的提高程序的并发执行速度，充分地发挥了多处理机的优越性，因而在近几年  
  的多处理机OS中引入了线程，以改善OS性能。

####线程的基本概念
  进程与线程的比较：
    1. 调度: 线程不拥有资源，更能轻装前进，从而显著提高系统的并发程度。
    2. 并发性: 从前只能进程之间并发，如锦同一个进程的多个线程之间也可以并发，更是大大提高了OS的性能
    3. 拥有资源: 不论是传统的操作系统还是引入了线程的操作系统，进程都是可以拥有资源的基本单位，线程不拥有
    4. 系统开销: 进程创建，资源分配，销毁都消耗大量系统精力，而线程的切换，同步和通信都无须操作系统内核的干预

####线程间的同步和通信
  1. 互斥锁
  2. 条件变量
  3. 信号量机制

####线程的实现方式
  1. 内核支持线程
  2. 用户级线程
  3. 组合方式

####线程的实现
  1. 内核支持线程的实现
  2. 用户级线程的实现
  3. 用户级线程与内核控制线程的连接


##第三章: 处理机调度与死锁

###调度算法
1. 先来先服务算法(比较有利于长作业，不利于短作业)
2. 高优先权调度算法
3. 基于时间片的轮转调度算法

###死锁

####产生死锁的原因和必要条件
  所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一个僵局
  
  必要条件：
  1. 互斥条件：指进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用，如果此时还有其他的进程  
  请求该资源，则请求者只能等待，直到占有的资源的进程用毕释放。
  2. 请求和保持条件： 指进程已经保持了至少一个资源，但是又提出新的资源请求，而该资源又已被其他资源占用，此时请求  
  阻塞，但又不会释放所占资源
  3. 不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完毕之后自己释放
  4. 环路等待条件：指在发生死锁时，必然存在一个进程---资源的环形链，即进程集合{P0, P1, P2, ...}中的P0正在等待一个  
  P1占用的资源，P1正在等待P2占用的资源...... Pn正在等待已被P0占用的资源。

####预防死锁的方法
  1. 摒弃“请求和保持”条件
  2. 摒弃"不剥夺"条件
  3. 摒弃“环路等待”条件

  银行家算法
  ```js
    Available[j] = Avaidable[j] - Request[j]
    Allocation[i, j] = Allocation[i, j] + Request[j]
    Need[i, j] = Need[j] - Request[j]
  ```

####死锁的检测和解除
  1. 剥夺资源
  2. 撤消进程

##第四章: 存储器管理

###页面置换算法

1. 最佳置换算法(未来不会使用的应该淘汰，仅是个理论算法)
2. 先进先出置换算法
3. 最近最久为使用(LRU)置换算法
4. Clock置换算法(LRU算法是比较好的，但是由于他要求较多硬件支持，故实际应用中，大多采用LRU的近似算法, Clock就是其一)



